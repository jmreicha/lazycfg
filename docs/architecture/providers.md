# Provider Architecture

This document describes the provider interface and architecture for lazycfg.

## Overview

Lazycfg uses a plugin-based architecture where each configuration type (AWS, Kubernetes, SSH, etc.) is implemented as a provider. Providers are registered with a central registry and orchestrated by the core engine.

## Provider Interface

All providers must implement the `Provider` interface defined in `internal/core/provider.go`:

```go
type Provider interface {
    Name() string
    Validate(ctx context.Context) error
    Generate(ctx context.Context, opts *GenerateOptions) (*Result, error)
    Backup(ctx context.Context) (string, error)
    Restore(ctx context.Context, backupPath string) error
    Clean(ctx context.Context) error
}
```

### Methods

#### Name()

Returns the unique identifier for the provider. This name is used for:

- Registration in the registry
- CLI commands (`lazycfg generate <name>`)
- Configuration file sections
- Backup directory organization

Examples: `"aws"`, `"kubernetes"`, `"ssh"`

#### Validate(ctx context.Context) error

Checks if all prerequisites for the provider are met. This includes:

- Required commands are installed
- Required configuration files exist
- Environment variables are set
- Dependencies are available

Returns an error if validation fails.

#### Generate(ctx context.Context, opts *GenerateOptions) (*Result, error)

Creates or updates the configuration files managed by this provider.

**GenerateOptions**:

- `DryRun`: Simulate generation without making changes
- `Force`: Overwrite existing files
- `Verbose`: Enable detailed logging
- `Config`: Provider-specific configuration (can be nil)

**Result** contains:

- `FilesCreated`: Paths to files that were created/modified
- `FilesSkipped`: Files that were skipped
- `Warnings`: Non-fatal issues encountered
- `Metadata`: Provider-specific data

#### Backup(ctx context.Context) (string, error)

Creates a backup of existing configuration files before generation. Returns the backup path or empty string if no backup was needed.

Backups are typically handled by the core engine's BackupManager, but providers can implement custom backup logic if needed.

#### Restore(ctx context.Context, backupPath string) error

Restores configuration from a backup. The `backupPath` should be a path returned by `Backup()`.

#### Clean(ctx context.Context) error

Removes all configuration files generated by this provider. This is useful for:

- Testing
- Complete environment reset
- Uninstallation

## Provider Lifecycle

The core engine orchestrates the provider lifecycle in this order:

1. **Validation** - Verify prerequisites are met
2. **Backup** - Create backup of existing config (unless `--no-backup`)
3. **Generation** - Create/update configuration files
4. **Rollback** (on error) - Restore from backup if generation fails

## Provider Registration

Providers must register themselves with the global registry. This typically happens in an `init()` function:

```go
func init() {
    core.GlobalRegistry.Register(&MyProvider{})
}
```

## Configuration

Providers can define their own configuration structure. Configuration is loaded from:

1. YAML config file (`~/.config/lazycfg/config.yaml`)
2. CLI flags
3. Defaults

Configuration precedence: CLI flags > YAML > defaults

Example YAML configuration:

```yaml
providers:
  aws:
    sso_start_url: https://example.awsapps.com/start
    sso_region: us-west-2
    steampipe:
      enabled: true
```

## Granted Provider

The Granted provider generates the `~/.granted/config` file with sane defaults for AWS credential management. It focuses solely on creating the Granted config file and does not handle AWS profile or registry generation.

Example configuration:

```yaml
providers:
  granted:
    enabled: true
    config_path: ~/.granted/config
    credential_process_auto_login: true
```

CLI usage:

```bash
# Generate Granted config
lazycfg generate granted

# Dry run
lazycfg generate granted --dry-run

# Overwrite existing config
lazycfg generate granted --force
```

## Kubernetes Provider

The Kubernetes provider discovers EKS clusters across AWS profiles and writes a merged kubeconfig file. It can also merge existing kubeconfig files from `~/.kube` without contacting AWS.

Example configuration:

```yaml
providers:
  kubernetes:
    enabled: true
    config_path: ~/.kube/config
    merge_enabled: false
    merge_only: false

    aws:
      credentials_file: ~/.aws/credentials
      profiles: []
      regions:
        - us-east-1
        - us-west-2
        - eu-west-1
      parallel_workers: 10
      timeout: 30s

    naming_pattern: "{profile}-{cluster}"

    merge:
      source_dir: ~/.kube
      include_patterns: ["*.yaml", "*.yml", "config"]
      exclude_patterns: ["*.bak", "*.backup"]
```

CLI usage:

```bash
# Generate kubeconfig for all EKS clusters
lazycfg generate kubernetes

# Generate with specific profiles or regions
lazycfg generate kubernetes --kube-profiles prod,staging
lazycfg generate kubernetes --kube-regions us-east-1,us-west-2

# Merge existing configs only
lazycfg generate kubernetes --kube-merge-only

# Discover clusters and merge existing configs
lazycfg generate kubernetes --kube-merge

# Dry run
lazycfg generate kubernetes --dry-run

# Demo mode with fake data
lazycfg generate kubernetes --kube-demo
```

## Error Handling

Providers should return descriptive errors that help users fix issues:

```go
if !commandExists("aws") {
    return fmt.Errorf("aws CLI not found: install from https://aws.amazon.com/cli/")
}
```

## Best Practices

1. **Idempotent Operations** - Generation should be safe to run multiple times
2. **Atomic Updates** - Use temporary files and atomic moves when possible
3. **Preserve User Data** - Don't overwrite user customizations without `--force`
4. **Clear Errors** - Provide actionable error messages with next steps
5. **Structured Logging** - Use the provided logger for consistent output
6. **Context Awareness** - Respect context cancellation for long operations
7. **File Permissions** - Set appropriate permissions on generated files (typically 0600 for configs)

## Example Provider Skeleton

```go
package myprovider

import (
    "context"
    "github.com/jmreicha/lazycfg/internal/core"
)

type MyProvider struct {
    backupManager *core.BackupManager
}

func init() {
    // Register provider at package initialization
    core.GlobalRegistry.Register(&MyProvider{
        backupManager: core.NewBackupManager(""),
    })
}

func (p *MyProvider) Name() string {
    return "myprovider"
}

func (p *MyProvider) Validate(ctx context.Context) error {
    // Check prerequisites
    return nil
}

func (p *MyProvider) Generate(ctx context.Context, opts *core.GenerateOptions) (*core.Result, error) {
    // Generate configuration files
    return &core.Result{
        Provider: p.Name(),
        FilesCreated: []string{},
    }, nil
}

func (p *MyProvider) Backup(ctx context.Context) (string, error) {
    // Create backup
    return "", nil
}

func (p *MyProvider) Restore(ctx context.Context, backupPath string) error {
    // Restore from backup
    return nil
}

func (p *MyProvider) Clean(ctx context.Context) error {
    // Remove generated files
    return nil
}
```

## Testing

Providers should include comprehensive tests:

- **Unit tests** for individual methods
- **Integration tests** with real file operations (use temp directories)
- **Validation tests** for prerequisite checking
- **Error cases** for failure scenarios

Use table-driven tests for validation and parsing logic.

## Future Considerations

- **Plugin Loading**: Dynamic provider loading from external binaries
- **Provider Dependencies**: Allow providers to depend on other providers
- **Hooks**: Pre/post generation hooks for custom logic
- **Templates**: Standardized template rendering helpers
