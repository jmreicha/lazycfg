package steampipe

import (
	"fmt"
	"strings"
	"unicode"
)

const fileHeader = "# This file was generated by cfgctl. Do not edit manually.\n"

// generateConnectionBlock renders a single steampipe connection block for an
// AWS profile, tagged with the managed marker. When ignoreErrorCodes is
// non-empty an ignore_error_codes line is included.
func generateConnectionBlock(profile, connectionName string, regions, ignoreErrorCodes []string) string {
	regionList := formatRegions(regions)
	var sb strings.Builder
	fmt.Fprintf(&sb, "%s\nconnection \"%s\" {\n  plugin  = \"aws\"\n  profile = \"%s\"\n  regions = %s",
		managedMarker, connectionName, profile, regionList)
	if len(ignoreErrorCodes) > 0 {
		fmt.Fprintf(&sb, "\n  ignore_error_codes = %s", formatRegions(ignoreErrorCodes))
	}
	sb.WriteString("\n}")
	return sb.String()
}

// formatRegions formats a slice of region strings as an HCL list literal.
func formatRegions(regions []string) string {
	if len(regions) == 0 {
		return `["*"]`
	}
	quoted := make([]string, len(regions))
	for i, r := range regions {
		quoted[i] = fmt.Sprintf("%q", r)
	}
	return "[" + strings.Join(quoted, ", ") + "]"
}

// sanitizeProfileName converts an AWS profile name to a valid HCL identifier,
// then prepends the configured prefix.
//
// Rules:
//   - Replace `/`, `-`, `.`, and whitespace with `_`
//   - Lowercase the result
//   - Prepend prefix
func sanitizeProfileName(profile, prefix string) string {
	var sb strings.Builder
	for _, r := range profile {
		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
			sb.WriteRune(unicode.ToLower(r))
		} else {
			sb.WriteRune('_')
		}
	}
	name := sb.String()
	// Collapse consecutive underscores.
	for strings.Contains(name, "__") {
		name = strings.ReplaceAll(name, "__", "_")
	}
	name = strings.Trim(name, "_")
	return prefix + name
}

// resolveRegions returns per-profile regions if configured, otherwise the
// default list.
func resolveRegions(profile string, defaultRegions []string, profileRegions map[string][]string) []string {
	if overrides, ok := profileRegions[profile]; ok && len(overrides) > 0 {
		return overrides
	}
	return defaultRegions
}

// dedupeByAccount groups profiles by their account name (the part before the
// first "/"), then selects one representative profile per account.
//
// Selection order:
//  1. The first profile whose role (part after "/") matches an entry in
//     preferredRoles (checked in preferredRoles order).
//  2. Otherwise the first profile encountered for that account.
//
// The returned slice preserves the order of first occurrence per account.
func dedupeByAccount(profiles []string, preferredRoles []string) []string {
	type accountEntry struct {
		profiles []string // all profiles for this account, in encounter order
	}
	seen := make(map[string]*accountEntry)
	var order []string // account names in first-encounter order

	for _, p := range profiles {
		account := p
		if idx := strings.Index(p, "/"); idx >= 0 {
			account = p[:idx]
		}
		key := sanitizeProfileName(account, "")
		if _, ok := seen[key]; !ok {
			seen[key] = &accountEntry{}
			order = append(order, key)
		}
		seen[key].profiles = append(seen[key].profiles, p)
	}

	result := make([]string, 0, len(order))
	for _, key := range order {
		entry := seen[key]
		result = append(result, selectProfile(entry.profiles, preferredRoles))
	}
	return result
}

// selectProfile returns the best profile from a group that all share the same
// account. It prefers profiles whose role matches an entry in preferredRoles
// (checked in order), falling back to the first profile in the group.
func selectProfile(profiles []string, preferredRoles []string) string {
	for _, role := range preferredRoles {
		for _, p := range profiles {
			if idx := strings.Index(p, "/"); idx >= 0 {
				if strings.EqualFold(p[idx+1:], role) {
					return p
				}
			}
		}
	}
	return profiles[0]
}

// connectionNameForProfile returns the connection name for a profile using
// only the account portion (before "/"), so that all roles for the same
// account map to a single connection name.
func connectionNameForProfile(profile, prefix string) string {
	account := profile
	if idx := strings.Index(profile, "/"); idx >= 0 {
		account = profile[:idx]
	}
	return sanitizeProfileName(account, prefix)
}
