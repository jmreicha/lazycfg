// Package granted provides a Granted configuration provider implementation.
package granted

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"

	"github.com/jmreicha/lazycfg/internal/core"
)

// ProviderName is the unique identifier for the Granted provider.
const ProviderName = "granted"

var (
	errProviderConfigNil   = errors.New("granted provider configuration is nil")
	errRestoreNotSupported = errors.New("restore not yet implemented for granted provider")
)

// Provider implements the core.Provider interface for Granted configuration management.
// It handles generation, backup, restoration, and cleanup of Granted configuration files.
type Provider struct {
	config *Config
}

// NewProvider creates a new Granted provider instance with the given configuration.
func NewProvider(config *Config) *Provider {
	if config == nil {
		config = DefaultConfig()
	}

	return &Provider{
		config: config,
	}
}

// Name returns the unique identifier for this provider.
func (p *Provider) Name() string {
	return ProviderName
}

// Validate checks if all prerequisites for this provider are met.
func (p *Provider) Validate(_ context.Context) error {
	if p.config == nil {
		return errProviderConfigNil
	}

	if !p.config.Enabled {
		return nil
	}

	return p.config.Validate()
}

// Generate creates the configuration files for this provider.
func (p *Provider) Generate(_ context.Context, opts *core.GenerateOptions) (*core.Result, error) {
	result := &core.Result{
		Provider:     p.Name(),
		FilesCreated: []string{},
		FilesSkipped: []string{},
		Warnings:     []string{},
		Metadata:     make(map[string]interface{}),
	}

	if p.config == nil {
		return nil, errProviderConfigNil
	}

	if opts != nil && opts.Config != nil {
		cfg, ok := opts.Config.(*Config)
		if !ok {
			return nil, errors.New("granted config has unexpected type")
		}
		p.config = cfg
	}

	if err := p.config.Validate(); err != nil {
		return nil, err
	}

	if !p.config.Enabled {
		result.Warnings = append(result.Warnings, "granted provider is disabled")
		return result, nil
	}

	configPath := p.config.ConfigPath

	_, err := os.Stat(configPath)
	fileExists := err == nil

	if fileExists && !opts.Force && !opts.DryRun {
		result.FilesSkipped = append(result.FilesSkipped, configPath)
		result.Warnings = append(result.Warnings, "config file exists, use --force to overwrite")
		return result, nil
	}

	configContent := p.buildConfigContent()

	if opts.DryRun {
		result.Warnings = append(result.Warnings, "dry-run mode: no files were actually created")
		result.Metadata["config_path"] = configPath
		result.Metadata["config_content"] = configContent
		return result, nil
	}

	configDir := filepath.Dir(configPath)
	if err := os.MkdirAll(configDir, 0700); err != nil {
		return nil, fmt.Errorf("failed to create config directory: %w", err)
	}

	if err := os.WriteFile(configPath, []byte(configContent), 0600); err != nil {
		return nil, fmt.Errorf("failed to write config file: %w", err)
	}

	result.FilesCreated = append(result.FilesCreated, configPath)

	return result, nil
}

// Backup creates a backup of existing configuration files.
func (p *Provider) Backup(_ context.Context) (string, error) {
	if p.config == nil {
		return "", nil
	}
	return core.BackupFile(p.config.ConfigPath)
}

// NeedsBackup reports whether a backup should be created before generation.
func (p *Provider) NeedsBackup(opts *core.GenerateOptions) (bool, error) {
	if p.config == nil {
		return false, nil
	}
	if opts != nil && opts.Config != nil {
		cfg, ok := opts.Config.(*Config)
		if !ok {
			return false, errors.New("granted config has unexpected type")
		}
		p.config = cfg
	}
	if !p.config.Enabled {
		return false, nil
	}
	if opts != nil && (opts.DryRun || !opts.Force) {
		if _, err := os.Stat(p.config.ConfigPath); err == nil {
			return false, nil
		}
	}
	return true, nil
}

// Restore recovers configuration from a backup.
func (p *Provider) Restore(_ context.Context, backupPath string) error {
	if backupPath == "" {
		return nil
	}

	return errRestoreNotSupported
}

// Clean removes all configuration files generated by this provider.
func (p *Provider) Clean(_ context.Context) error {
	return nil
}

// buildConfigContent generates the Granted config file content.
func (p *Provider) buildConfigContent() string {
	return fmt.Sprintf(`DefaultBrowser = %q
CustomBrowserPath = %q
CustomSSOBrowserPath = %q
Ordering = %q
ExportCredentialSuffix = %q
DisableUsageTips = %t
CredentialProcessAutoLogin = %t
`,
		p.config.DefaultBrowser,
		p.config.CustomBrowserPath,
		p.config.CustomSSOBrowserPath,
		p.config.Ordering,
		p.config.ExportCredentialSuffix,
		p.config.DisableUsageTips,
		p.config.CredentialProcessAutoLogin,
	)
}
